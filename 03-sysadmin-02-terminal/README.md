# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
   > Ответ: это встроенная builtin команда оболочки bash, не порождающая процесс с PID при вызове. Т.е. `cd` не утилита и не программа, т.к. она отсутствует в файловой системе как исполняемый файл. Она просто меняет текущую рабочую директорию.
   > ```
   > $ type cd
   > cd is a shell builtin
   > ```
1. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.
   > Ответ:
   > ```
   > grep -c <some_string> <some_file>
   > ```
1. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
   > Ответ: Я не использую для ДЗ virtualbox + vagrant из-за проблем с корпоративным антивирусом Касперского. Поэтому сижу пока на Ubuntu 20.04.2 LTS через WSL Windows 10. Поэтому отвечаю на вопрос, сидя в WSL: это процесс /init:
   > ```
   > $ pstree -p
   > init(1)─┬─init(6)───bash(7)───pstree(599)
   >         └─{init}(5)
   > $ ps u 1
   > USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
   > root         1  0.0  0.0   8940   528 ?        Ssl  May24   0:00 /init
   > ```
1. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
   > Ответ: предварительно я смотрю, на каком текущем терминале я работаю; и также смотрю вывод ошибки отображения списка файлов несуществующей директории /ddd в текущий терминал. Поэтому ответ на вопрос - это последняя команда в списке:
   > ```
   > # tty
   > /dev/tty1
   > # ls /ddd
   > ls: cannot access '/ddd': No such file or directory
   > ls /ddd 2>/dev/tty2
   > ``` 
1. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
   > Ответ: Да, получится. Первая команда в списке и есть ответ:
   > ```
   > $ grep found < ~/123.log > 321.log
   > $ cat 123.log
   > bash: line 2: s: command not found
   > bash: line 3: 111: command not found
   > bash: line 4: /dd: No such file or directory
   > $ cat 321.log
   > bash: line 2: s: command not found
   > bash: line 3: 111: command not found
   > ```
1. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
   > Ответ: Да, получится. Данные вывода содержимого директории /home, отправленные из графического терминала /dev/pts/0 могу наблюдать в эмуляторе терминала /dev/tty3:
   > ``` 
   > $ ls /home > /dev/tty3
   > ```
1. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
   > Ответ: команда `bash 5>&1` создает новый поток bash с дескриптором № 5 и перенаправляет его на стандартный поток вывода с дескриптором № 1. А дальнейшая команда `echo netology > /proc/$$/fd/5` перенаправляет выходной поток команды echo на 5-й дескриптор процесса bash, который мы создали и перенаправили предыдущей командой. Т.е. фактически мы выводим слово netology на экран транзитом через перенаправленный на стандартный вывод 5-й поток. Поэтому и видим слово netology как результат работы команды `echo netology > /proc/$$/fd/5`.
1. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
   > Ответ: в коде ниже я ответил как это сделать. В результате мы продолжаем видеть stdout на pty (это dir1), при этом только ошибки об отсутствии папок non_exist_dir2 и non_exist_dir3 попадают на pipe in при создании файла errdir.log утилитой tee. Использовал я для этого создание 5-го дескриптора как копии stdout из предыдущего вопроса.   
   > ```
   > $ ls
   > dir1
   > $ ls -d dir1
   > dir1
   > $ ls -d dir1 non_exist_dir2 non_exist_dir3
   > ls: невозможно получить доступ к 'non_exist_dir2': Нет такого файла или каталога
   > ls: невозможно получить доступ к 'non_exist_dir3': Нет такого файла или каталога
   > dir1
   > $ bash 5>&1
   > $ ls -d dir1 non_exist_dir2 non_exist_dir3 2>&1 1>/proc/$$/fd/5 | tee errdir.log
   > dir1
   > ls: невозможно получить доступ к 'non_exist_dir2': Нет такого файла или каталога
   > ls: невозможно получить доступ к 'non_exist_dir3': Нет такого файла или каталога
   > $ cat errdir.log
   > ls: невозможно получить доступ к 'non_exist_dir2': Нет такого файла или каталога
   > ls: невозможно получить доступ к 'non_exist_dir3': Нет такого файла или каталога
   > ```
1. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
   > Ответ: команда выводит переменные окружения для текущего процесса bash, заданные на этапе запуска этого процесса. Аналогичный вывод можно сделать командой `env`. Эта команда покажет большее количество переменных окружения. 
1. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
   > Ответ: `/proc/<PID>/cmdline` содержит параметры командной строки, переданные на этапе запуска процесса, но хранится эта информация до момента пока процесс не стал зомби-процессом.
   > 
   > `/proc/<PID>/exe` содержит символьную ссылку на исполненный бинарный файл запущенного процесса 
1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
   > Ответ: `sse4_2`
1. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.
   > Ответ: нужно просто добавить к команде ssh параметр -t, чтобы выполнить команду tty в удаленной сессии ssh localhost:
   > ```
   > w-awank@wawank-VirtualBox:~$ tty
   > /dev/pts/1
   > w-awank@wawank-VirtualBox:~$ ssh -t localhost 'tty'
   > w-awank@localhost's password:
   > /dev/pts/2
   > Connection to localhost closed.
   > ```
1. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
   > Ответ: для выполнения этого задания я запустил в ssh сессии /dev/pts/1 программу `top`, затем в домашней консольной сессии /dev/pts/0 посмотрел список всех процессов командой `ps -a`, увидел PID процесса `top` из сессии pts/1 и захватил его в текущую сессию pts/0 командой `reptyr -T 6314` и попал в интерактив программы `top`, нажал `q` чтобы выйти из `top`, и завершил перехваченную сессию командой `exit`, вернувшись после этого в домашнюю сессию, из которой делал перехват.     
1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
   > Ответ: Так происходит потому, что мы запускаем с правами суперпользователя команду echo и она честно выводит строку `string` в стандартный вывод bash с правами суперпользователя. Но bash запущен от обычного пользователя, и когда интерпретатор bash пытается записать полученную строчку в файл домашней директории суперпользователя /root, естественно, что мы получаем ошибку. Поэтому для решения задачи можно использовать команду tee, которая читает стандартный ввод, переданный ей через pipe, и записывает его в стандартный вывод или файл уже с повышенными привилегиями sudo.


 
 ---

### Как оформить ДЗ?

Домашнее задание выполните в файле readme.md в github репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.

Также вы можете выполнить задание в [Google Docs](https://docs.google.com/document/u/0/?tgif=d) и отправить в личном кабинете на проверку ссылку на ваш документ.
Название файла Google Docs должно содержать номер лекции и фамилию студента. Пример названия: "1.1. Введение в DevOps — Сусанна Алиева"
Перед тем как выслать ссылку, убедитесь, что ее содержимое не является приватным (открыто на комментирование всем, у кого есть ссылка). 
Если необходимо прикрепить дополнительные ссылки, просто добавьте их в свой Google Docs.

Любые вопросы по решению задач задавайте в чате Slack.

---